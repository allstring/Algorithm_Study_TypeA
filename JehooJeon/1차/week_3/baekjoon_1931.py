# 1931. 회의실 배정

import sys
sys.stdin = open('input.txt', 'r')

'''
    이 문제는 블로그의 풀이를 일부 참고하였음
    
    문제유형 파악 : 
    회의의 수 범위가 1 ~ 100,000이고, 시작 시간과 끝나는 시간이 0 ~ 2^31 - 1 이기 때문에
    완전 탐색이나 DP는 아닐 것이라 생각했고 결국엔 그리디 문제라는 결론을 내렸음
    
    풀이과정 : 
    1. 회의의 최대 개수를 구하기 위해서 시작 시간을 기준으로 생각해 보았음
    -> list를 만들어서 각 시간별로 회의가 진행된 여부를 0, 1로 표현하려고 하였는데, 범위가 너무 넓은 관계로 실패
    -> 그리디로 생각을 해보았을 때, 도저히 시작 시간을 기준으로 회의의 '최대 개수'를 구할 idea가 떠오르지 않음
    2. 블로그의 idea를 참고 하였음 => 끝나는 시간을 기준으로 진행
    -> 끝나는 시간을 기준으로 회의의 최대 개수를 구하기 위해서 끝나는 시간 기준으로 오름차순 정렬
    -> 이전 끝나는 시간과 가장 가까운 시작 시간을 가진 회의를 찾기 위해 이후에 시작 시간 기준으로 오름차순 정렬
    -> 끝나는 시간을 갱신하면서 가장 가까운 시작 시간과 끝나는 시간을 가진 회의를 지속적으로 찾으면서 회의 개수 추가

'''

def main():
    # N: 회의의 수 (1 <= N <= 100,000)
    N = int(input())
    # meeting: 시작 시간, 끝나는 시간 리스트
    meeting = [list(map(int, input().split())) for _ in range(N)]

    # 끝나는 시간 오름차순 정렬 -> 시작 시간 오름차순 정렬
    meeting.sort(key=lambda x: (x[1], x[0]))
    # print(meeting)
    
    # end_point: 마지막 회의가 끝나는 시간
    end_point = 0
    # cnt: 회의의 개수
    cnt = 0
    for start, end in meeting:
        # 만약 시작 시간이 이전 회의 끝나는 시간과 같거나 이후라면
        # 회의의 개수를 추가하고 end_point 갱신
        if start >= end_point:
            cnt += 1
            end_point = end

    print(cnt)

if __name__ == "__main__":
    main()
